# Защита Информации

# Лабораторная работа №1
Реализовать программу шифрования произвольного файла алгоритмом Энигмы.

Энигма состоит из трех роторов и рефлектора. При прохождении через ротор буква меняется на другую. После каждого зашифрованного символа ротор поворачивается. После трех роторов буква поступает на рефлектор, "разворачивается" и движется в обратную сторону через три ротора. На выходе — зашифрованный символ.

Зачем нужен рефлектор? Для использования машины как для шифрования, так и для дешифрования.

Главное свойство рефлектора: A → B, B → A. Будет вопрос на защите.

Шифрование произвольных файлов, не только текстовых.

## Цель

Целью данной работы является создание программы, которая повторяет работу шифровального аппарата "Энигма".

## Часто задаваемые вопросы

### Вопроc: Как заполняется ротор?

__Ответ__: Пермешивание изначального алфавита


### Вопроc: Как заполняется рефлектор?

__Ответ__: Попарно в виде словаря - берутся по два символа алфавита и первый становится ключом для второго, а второй - ключом для первого


### Вопроc: Как отличается размер шифрованного файла от начального?

__Ответ__: Никак, байт в байт идентичны


### Вопроc: Чем отличается процесс шифровки от дешифровки?

__Ответ__: Ничем


### Вопроc: Если длина файла m символов, то сколько раз повернется 1-й ротор? а второй? а третий?

__Ответ__: m; m//256; m//(256**2)


### Вопроc: По какому принципу работает ротор?

__Ответ__: Прямой ход:
1. Находится позиция ПРИШЕДШЕЙ буквы = позиция в ОБЫЧНОМ алфавите + СМЕЩЕНИЕ по ротору (позиция)
2. По найденной позиции берется буква из ПЕРЕМЕШАННОГО алфавита

Обратный ход:
1. Находится позиция ПРИШЕДШЕЙ буквы = позиция в ПЕРЕМЕШАННОМ алфавите - СМЕЩЕНИЕ по ротору (позиция)
2. По найденной позиции берется буква из ОБЫЧНОГО алфавита

Вращается ротор: 1ый - на каждом элементе, 2ой - когда повернется 1ый, 3ий - когда повернется 2ой и тд


### Вопроc: Какое главное свойство рефлектора?

__Ответ__: Рефлектор должен иметь зеркальное соответствие (по `X` возвращается `Y`, по `Y` - `X`) (поэтому алфавит должен быть четного размера)


### Вопроc: Зачем нужен рефлектор?

__Ответ__: Рефлектор нужен для того, чтобы на одних и тех же настройках (одинакое положение роторов, одинаковые алфавиты) использовать машину как для шифрования, так и дешифрования

### Как был реализован ротор? Как вращается ротор?
У структуры rotor два поля: массив байтов и количество вращений. Когда на вход подается символ, у символа есть какое-то число от 0 до 255, и оно используется как индекс. По массиву с индексом получается следующее значение, которое подаётся на следующий вход.

Ротор вращается так: происходит сдвиг на 1 значений по индексам, последний элемент становится первым, и всё сдвигается на один элемент влево. Если провернулся ровно N раз, то счетчик обнуляется.

Роторы вращаются по очереди. Как только первый ротор закончил полный круг, то следующий ротор повернется на один элемент.

### Как мы заполняем роторы?
По коду: заполняем сначала значение = index, а затем вызываю функцию shuffle из пакета random

### Какое основное свойство рефлектора?
Рефлектор симметричен: если при подаче символа A рефлектор выдаёт B, то если подать символ B, то рефлектор выдаст символ A.

Также рефлектор не вращается в ходе работы программы. 

### Как был заполнен рефлектор?
Рефлектор был заполнен следующим образом: символу с номером i ставился в соответствии символ с номером 255-i. Алфавит должен быть чётным!

### Чем отличается процесс шифровки от дешифровки?
Ничем. Для дешифровки нужно роторы и рефлектор привести к тому же виду, в каком они были изначально при шифровке. Через энигму нужно пропустить зашифрованный текст, чтобы получить исходный.

### Отличается ли размер зашифрованного файла от исходного?
Нет, байт в байт.

### Если длина файла M символов, то сколько раз повернется 1, 2 и 3 роторы?
Первый ротор повернется M раз, второй ротор повернется M // 256 раз, а третий ротор повернется M // (256^2) раз.

### Чем отличается прямой ход от обратного хода?
В целом ничем, но во время прямого хода ищется значение в массиве по индексу, а во время обратного хода ищется индекс определенного значения в массиве.


# Как это работает

Кратко:

1. Энигма состоит из коммутационной панели (в данной лабе не реализовывалась),
   роторов (обычно 3, были Энигмы и с большим числом) и рефлектора.

2. На коммутационной панели буквы соединялись парами (возможно, соединялись
   только некоторые буквы). Соединенные буквы менялись местами (то есть,
   например, при нажатии А изменялась на B, а B -- на A), и на вход роторам
   подавался измененный сигнал.

3. Каждый ротор -- шестерня, реализующая замену. Каждой букве алфавита ставится
   в соответствие другая буква этого же алфавита случайным образом. В
   лабораторной ротор реализован с помощью списка, описывающего, как перемешаны
   буквы в выходном алфавите, и целого числа, описывающего текущую позицию
   ротора. Зачем позиция? Дело в том, что роторы вращаются (см. пункт 6).

4. Рефлектор (англ. reflect -- отражать) попарно соединяет буквы одного
   алфавита. То есть весь алфавит делится на пары (поэтому в алфавите должно
   быть четное число букв), и при поступлении на вход буквы на выход подается
   ее "напарник" (например, если алфавит `abcd`, и есть пары `ad` и `bc`, то при
   входе `a` возращается `d`, при `d` -- `a`, при `b` -- `c`, при `c` -- `b`).
   Это свойство обеспечивает возможность использовать одну и ту же машину, как
   для шифрования, так и для расшифровки, необходимо только начинать оба
   действия при одних и тех же положениях роторов.

5. Как все это соединено? Три ротора соединены последовательно, на вход второго
   ротора подается выход первого, на вход третьего -- выход второго, рефлектору
   подается выход третьего рефлектора. Далее следует обратный ход, на нем
   рефлекторы работают наоборот, буква ищется в выходном алфавите, а
   возвращается буква из входного. Также буква через роторы проходит в обратном
   порядке: выход рефлектора подается третьему ротору, выход третьего --
   второму, выход второго -- первому. После такого "прогона" одной буквы роторы
   вращаются.

6. Первый ротор вращается после полного прохода каждой буквы, второй -- после
   того, как первый ротор сделает полный круг, вернувшись в начальную позицию,
   третий -- после того, как второй сделает полный круг (аналогично часам).

7. Готово. Для того, чтобы расшифровать сообщение, надо устновить роторы в те
   положения, при которых начиналось шифрование.

Подробно (или просто почитать и посмотреть):

[Картинки + код](https://medium.com/analytics-vidhya/how-to-build-an-enigma-machine-virtualisation-in-python-b5476a1fd922)

[Описание на русском](http://mediaknowledge.ru/ef0727594332a76f.html#.D0.9A.D0.BE.D0.BC.D0.BC.D1.83.D1.82.D0.B0.D1.86.D0.B8.D0.BE.D0.BD.D0.BD.D0.B0.D1.8F_.D0.BF.D0.B0.D0.BD.D0.B5.D0.BB.D1.8C)

[Листки с настройками Энигмы](https://ogn-slon.livejournal.com/293415.html)

[Еще описание на русском](https://habr.com/en/post/534066/)

[Красиво и полезно](https://www.youtube.com/watch?v=ybkkiGtJmkM) (ссылочкой
поделилась [@hamzreg](https://github.com/hamzreg))

https://www.youtube.com/watch?v=emmJXmdi41Z2U

# Вопросики

1. Как заполняете ротор, рефлектор (по коду)?

Ротор простым перемешиванием, рефлектор -- перемешиванием и добавлением соседних
элементов в словарь, как пар "ключ-значение"

2. Зачем рефлектор?

Чтобы при одних и тех же начальных настройках можно было как зашифровать, так и
расшифровать, то есть чтобы шифрование ничем не отличалось от расшифровки.

3. Что такого делает рефлектор, что шифрование и дешифрование ничем не
   отличаются?

Он преобразует значение (букву) в индекс, а индекс -- в значение (букву).

4. \+ надо понимать порядок действий: прямой ход (получение значения по
   индексу), рефлектор, обратный ход (получение индекса по значению), поворот
роторов (когда какой ротор вращается, сколько каждый из роторов повернется при x
буквах).

* **Как заполняются роторы и рефлектор?**  
  У меня заполняется массив числами от 0 до 255 и перемешивается.
* **Какой ход быстрее - прямой или обратный?**  
  В этой реализации - прямой. В прямом - индексация в массиве. В обратном - поиск в массиве.
* **Зачем нужен рефлектор?**  
  Чтобы была возможна дешифрация на той же конфигурации.
* **Как происходит дешифрация?**  
  Дешифрованный файл получается путем шифрования зашифрованного файла на конфигурации при первоначальном шифровании
* **Изменяется ли размер файла на выходе?**  
  Нет, не изменяется. При шифровании один байт шифруется в один байт.
